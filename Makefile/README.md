# Makefile Basics

## Table of Contents

- [Introduction](#what-is-make)
- [Basic Syntax](#basic-syntax)
- [Variables ](#variables-in-makefiles)
- [Conditions](#conditions-in-makefiles)
- [Loops](#loops-in-makefiles)
- [Functions](#functions-in-makefiles)
- [Moreover](#)

# What is Make? 

Make is a build automation tool that automatically builds executable programs and libraries from source code by reading files called Makefiles.

# What is a Makefile?

A Makefile is a file containing a set of directives and rules, which describe how to compile and link a program. Make reads the Makefile and executes the necessary commands to update the target files if any of the dependencies have changed.

# Basic Syntax

A Makefile consists of rules, which have the following basic syntax:

```make
target: dependencies
    [tab] commands
```

- **Target**: Represents the file(s) that are generated by the rule.

- **Dependencies**: Files that the target depends on. 

- **Commands**: Shell commands to execute. They must be preceded by a tab character.

## Example :

```make 
output: input1 input2
    gcc -o output input1 input2
```

# Variables in Makefiles

## Defining variable

Variables in a Makefile can be defined using the following syntax:

```make
VARIABLE_NAME := value
```

## Substitute Variables

Variables in a Makefile can be substituted using the following syntax:

```make
$(Variable_Name)
```
## Example :

```make 
CC := gcc
CFLAGS := -Wall -O2

all:
    $(CC) $(CFLAGS) -o output source.c
```

# Conditions in Makefiles

## Conditional Directives

Makefiles support several conditional directives, including:

- `ifeq (arg1, arg2)`   : Tests if `arg1` is equal to `arg2`.
- `ifneq (arg1, arg2)`  : Tests if `arg1` is not equal to `arg2`.
- `ifdef variable_name` : Tests if `variable_name` is defined.
- `ifndef variable_name`: Tests if `variable_name` is not defined.

These directives provide flexibility in determining which commands to execute or which variables to set based on the outcome of the condition.

## Example

Here's an example of using conditional statements in a Makefile:

```make
# Define variable DEBUG
DEBUG := true

# Conditional compilation based on DEBUG value
ifeq ($(DEBUG), true)
    CFLAGS := -01
else
    CFLAGS := -O2
endif
```

# Loops in Makefiles

## Bash Style
In Makefiles, you can simulate loops using the shell commands directly within the Makefile. Since Makefiles allow executing shell commands, you can leverage Bash scripting to create loop-like behavior.

## Example

Here's an example of using bash style loops in a Makefile:

```make
# Define a list of items
ITEMS := item1 item2 item3

# Rule to process each item
process:
    @for item in $(ITEMS); do \
        echo "Processing $$item"; \
        # Add your processing commands here \
    done

```

## Foreach function
In Makefiles, the **foreach** function allows you to iterate over a list of words and apply a  set of actions to each word. It's useful for performing repetitive tasks.

## Example
```make
# Define a list of items
ITEMS := apple banana orange

# Define a rule to print each item
print_items:
    @$(foreach item,$(ITEMS),echo $(item);)
```

# Functions in Makefiles

## Function Decleration
In Makefiles, you can define your own custom functions using the **define** directive. This allows you to create reusable pieces of code to perform specific tasks within your Makefile. 

## Example

 ```make
 # Define a custom function to print a message
define print_message
    @echo "Message: $1"
endef
```

## Bultin Functions
In Makefiles, functions are used to perform various tasks such as string manipulation, file operations, and conditional evaluation. Make provides a set of built-in functions that you can use to customize your build process.

Here are some commonly used functions in Makefiles:

#### File Functions:
- `wildcard`: Find files matching a pattern.
- `shell`: Execute shell commands and capture their output.
- `foreach`: Iterate over a list and perform actions for each item.
- `if/ifeq/ifneq`: Conditional evaluation.

# Moreover

## Phony
In a Makefile, a **phony** target is a target that does not represent a file. Instead, it's a label for an action or set of actions that Make should execute. Phony targets are typically used for tasks like compiling code, cleaning up files, or running tests, where the target name doesn't correspond to an actual file in the filesystem.

## Example
``` make
.PHONY: clean

clean:
    rm -f *.o
```

## Includes
In a Makefile, the **include** directive is used to include the contents of another file into the current Makefile. This feature allows you to modularize your Makefiles by separating different parts into separate files and including them where needed.
## Example
``` make
include file_name
```

## Automatic Variables
In Makefiles, automatic variables are special variables that provide information about the current target, prerequisites, etc.

Here are some common automatic variables used in Makefiles:

- `$@`: Represents the target filename. It is used to refer to the target of the rule.
- `$<`: Represents the first prerequisite filename. It is used to refer to the first prerequisite of the rule.
- `$^`: Represents all the prerequisites filenames. It is used to refer to all the prerequisites of the rule.
- `$?`: Represents all the prerequisites that are newer than the target. It is used to refer to prerequisites that have changed since the target was last modified.
- `$*`: Represents the stem of the target filename. It is used to refer to the part of the filename without its suffix.